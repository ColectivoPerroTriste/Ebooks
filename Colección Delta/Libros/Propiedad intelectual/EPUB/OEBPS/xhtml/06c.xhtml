<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:epub="http://www.idpf.org/2007/ops"
	  xml:lang="es-MX">
    <head>
        <link href="../css/principal.css" rel="stylesheet" type="text/css" />
        <meta charset="UTF-8" />
        <title>La catedral y el bazar</title>
    </head>
    <body>
        <!-- Artículo -->
        <h1>La catedral y el bazar</h1>
        <p>Eric Steven Raymond</p>
        <p>Analizo un exitoso proyecto de <em>software</em> libre (Fetchmail), que fue realizado para probar deliberadamente algunas sorprendentes ideas sobre la ingeniería de <em>software</em> sugeridas por la historia de Linux. Discuto estas teorías en términos de dos estilos de desarrollo fundamentalmente opuestos: el modelo catedral, de la mayoría de los fabricantes de <em>software</em> comercial, contra el modelo bazar, del mundo Linux. Demuestro que estos modelos parten de puntos de vista contrapuestos acerca de la naturaleza de la tarea de depuración de <em>software</em>. Posteriormente hago una argumentación a partir de la experiencia de Linux de la siguiente sentencia: «si se tienen las miradas suficientes, todas las pulgas saltarán a la vista». Al final, sugiero algunas fructíferas analogías con otros sistemas autorregulados de agentes individuales y concluyo con una somera expCrimsonción de las implicaciones que pude tener este enfoque en el futuro del <em>software</em>.</p>
        <h2>La catedral y el bazar</h2>
        <p>Linux es subversivo. ¿Quién hubiera pensado hace apenas cinco años que un sistema operativo de talla mundial surgiría, como por arte de magia, gracias a la actividad <em>hacker</em> desplegada en ratos libres por varios programadores diseminados en todo el planeta, conectados solamente por los tenues hilos del internet?</p>
        <p>Lo que sí es seguro es que yo no. Cuando Linux apareció en mi camino, a principios de 1993, yo tenía invertidos en Unix y en el desarrollo de <em>software</em> libre alrededor de diez años. Fui uno de los primeros en contribuir con <span class="versalitas">gnu</span> a mediados de los ochenta y he estado aportando una buena cantidad de <em>software</em> libre a la red, desarrollando o colaborando en varios programas (NetHack, los modos Version Control y Grand Unified Debugger de Emacs, Xlife, entre otros) que todavía son ampliamente usados. Creí que sabía cómo debían hacerse las cosas.</p>
        <p>Linux vino a trastocar buena parte de lo que pensaba que sabía. Había estado predicando durante años el evangelio Unix de las herramientas pequeñas, de la creación rápida de prototipos y de la programación evolutiva. Pero también creía que existía determinada complejidad crítica, por encima de la cual se requería un enfoque más planeado y centralizado. Yo pensaba que el <em>software</em> de mayor envergadura (sistemas operativos y herramientas realmente grandes, tales como Emacs) requería construirse como las catedrales; es decir, que debía ser cuidadosamente elaborado por genios o pequeñas bandas de magos trabajando encerrados a piedra y lodo, sin liberar versiones beta antes de tiempo.</p>
        <p>El estilo de desarrollo de Linus Torvalds («libere rápido y a menudo, delegue todo lo que pueda, sea abierto hasta el punto de la promiscuidad») me cayó de sorpresa. No se trataba de ninguna forma reverente de construir la catedral. Al contrario, la comunidad Linux se asemejaba más a un bullicioso bazar de Babel, colmado de individuos con propósitos y enfoques dispares (fielmente representados por los repositorios de archivos de Linux, que pueden aceptar aportaciones de quien sea), de donde surgiría un sistema estable y coherente únicamente a partir de una serie de artilugios.</p>
        <p>El hecho de que este estilo de bazar pareciera funcionar, y funcionar bien, realmente me dejó sorprendido. A medida que iba aprendiendo a moverme en ese medio, no solo trabajé arduamente en proyectos individuales: también traté de comprender por qué el mundo Linux no naufragaba en el mar de la confusión, pues se fortalecía con una rapidez inimaginable para los constructores de catedrales.</p>
        <p>A mediados de 1996 creí empezar a comprender. El destino me dio un medio perfecto para demostrar mi teoría, en forma de un proyecto de <em>software</em> libre que trataría de realizar siguiendo el estilo bazar de manera consciente. Así lo hice y resultó un éxito digno de consideración.</p>
        <p>En el resto de este artículo&#160;relataré la historia de este proyecto y la usaré para proponer algunos aforismos sobre el desarrollo real de <em>software</em> libre. No todas estas cosas fueron aprendidas del mundo Linux, pero veremos cómo fue que este les vino a otorgar un sentido particular. Si estoy en lo cierto, te servirán para comprender mejor qué es lo que hace a la comunidad linuxera tan buena fuente de <em>software</em> y te ayudarán a ser más productivo.</p>
        <h2>El correo tenía que llegar</h2>
        <p>Desde 1993 he estado encargado de la parte técnica de un pequeño proveedor de servicios de internet (<span class="versalitas">isp</span>, por sus siglas en inglés) de acceso gratuito llamado Chester County InterLink (<span class="versalitas">ccil</span>) en West Chester, Pensilvania (fui uno de los fundadores de <span class="versalitas">ccil</span> y escribí su original <em>software</em> <span class="versalitas">bbs</span> multiusuario que actualmente soporta más de tres&#160;mil usuarios en diecinueve líneas). Este empleo me permitió tener acceso a la red las veinticuatro horas del día a través de la línea de 56k de <span class="versalitas">ccil</span>; de hecho, ¡el trabajo prácticamente me lo demandaba!</p>
        <p>Para ese entonces ya me había habituado al correo electrónico. Por diversas razones fue difícil obtener un Serial Line Internet Protocol (<span class="versalitas">slip</span>) para enlazar mi máquina en <a target="_blank" href="http://snark.thyrsus.com/">casa</a> con <span class="versalitas">ccil</span>. Cuando finalmente lo logré, encontré que era particularmente molesto tener que entrar desde Telnet a Locke continuamente para revisar mi correo. Lo que quería era que se reenviara a Snark para recibir notificaciones cuando me llegara y poder manejarlo usando mis herramientas locales.</p>
        <p>Un simple redireccionamiento con Sendmail no iba a funcionar, debido a que Snark no siempre está en línea y no tiene una dirección <span class="versalitas">ip</span> estática. Lo que necesitaba era un programa que saliera por mi conexión <span class="versalitas">slip</span> y trajera el correo hasta mi máquina. Yo sabía que tales programas ya existían y que la mayoría usaba un protocolo simple llamado Protocolo de Oficina de Correos (<span class="versalitas">pop</span>), así que me cercioré de que el servidor <span class="versalitas">pop</span> 3 estuviera en el sistema operativo <span class="versalitas">bsd/os</span> de Locke.</p>
        <p>Necesitaba un cliente <span class="versalitas">pop</span> 3, de tal manera que lo busqué en la red y encontré uno. En realidad hallé tres o cuatro. Usé <span class="versalitas">pop</span> Perl durante un tiempo, pero le faltaba una característica a todas luces evidente: la capacidad de identificar las direcciones de los correos recuperados para poder contestarlos correctamente.</p>
        <p>El problema era este: supongamos que un tal Monty en Locke me enviaba un correo. Si yo lo hacía llegar desde Snark y luego intentaba responder, entonces mi programa de correos dirigía la respuesta a un Monty inexistente en Snark. En poco tiempo, la edición manual de las direcciones de respuesta para pegarles el <samp>@ccil.org</samp>  se volvió algo muy molesto.</p>
        <p>Era evidente que la computadora tenía que hacer esto por mí. (De hecho, de acuerdo con <span class="versalitas">rfc</span>&#160;1123, sección&#160;5.2.18, Sendmail tenía que hacerlo). Sin embargo, ¡ninguno de los clientes <span class="versalitas">pop</span> lo hacía realmente! Esto nos lleva a la primera lección:</p>
        <blockquote id="afor1"><strong>1. Todo buen trabajo de <em>software</em> comienza a partir de las necesidades personales de quien programa. (Todo buen trabajo empieza cuando uno tiene que rascarse su propia comezón).</strong></blockquote>
        <p>Esto podría sonar muy obvio: el viejo proverbio dice que «la necesidad es la madre de todos los inventos». Empero, hay muchos programadores de <em>software</em> que gastan sus días a cambio de un salario en programas que ni necesitan ni quieren. No ocurre lo mismo en el mundo Linux, lo cual sirve para explicar por qué la calidad promedio de <em>software</em> es tan alta en esa comunidad.</p>
        <p>Por todo esto, ¿pensarán que me lancé inmediatamente a la vorágine de escribir a partir de cero el programa de un nuevo cliente <span class="versalitas">pop</span> 3 que compitiese con los existentes? ¡Nunca en la vida! Revisé cuidadosamente las herramientas <span class="versalitas">pop</span> que tenía al alcance, preguntándome «¿cuál se aproxima más a lo que yo necesito?», porque:</p>
        <blockquote id="afor2"><strong>2. Los buenos programadores saben qué escribir. Los mejores, qué rescribir (y reutilizar).</strong></blockquote>
        <p>Aunque no presumo ser un extraordinario programador, trato de imitarlos. Una importante característica de los grandes programadores es la meticulosidad con la que construyen. Saben que les pondrán diez, no por el esfuerzo sino por los resultados, y que casi siempre será más fácil partir de una buena solución parcial que desde cero.</p>
        <p>Linus, por ejemplo, no intentó escribir Linux partiendo de cero. En vez de eso, comenzó por reutilizar el código y las ideas de Minix, un pequeño sistema operativo (<span class="versalitas">os</span>, por sus siglas en inglés) tipo Unix, hecho para máquinas 386. Eventualmente terminó desechando o rescribiendo todo el código de Minix, pero mientras contó con él le sirvió como una importante plataforma de lanzamiento para el proyecto en gestación que posteriormente se convertiría en Linux.</p>
        <p>Con ese espíritu comencé a buscar una herramienta <span class="versalitas">pop</span> que estuviese razonablemente bien escrita, para usarla como plataforma inicial de desarrollo.</p>
        <p>La tradición del mundo Unix de compartir las fuentes siempre se ha prestado a la reutilización del código (esta es la razón por la que el proyecto <span class="versalitas">gnu</span> escogió a Unix como su sistema operativo base, pese a las serias reservas que se tenían). El mundo Linux ha asumido esta tradición hasta llevarla muy cerca de su límite tecnológico; posee terabits de código fuente que están generalmente disponibles. Por eso es que la búsqueda de algo bueno tiene mayores probabilidades de éxito en el mundo Linux que en ningún otro lado.</p>
        <p>Así sucedió en mi caso. Además de los que había encontrado antes, en mi segunda búsqueda conseguí un total de nueve candidatos: Fetchpop, PopTart, Getmail, Gwpop, Pimp, <span class="versalitas">pop</span> Perl, Popc, Popmail y Upop.&#160;El primero que elegí fue Fetchpop, un programa de Seung-Hong Oh. Le agregué mi código para que tuviera la capacidad de rescribir los encabezados y varias mejoras más, las cuales fueron incorporadas por el propio autor en la versión 1.9.</p>
        <p>Sin embargo, unas semanas después me topé con el código fuente de Popclient, escrito por Carl Harris, y descubrí que tenía un problema. Pese a que Fetchpop poseía algunas ideas originales (como su modo <em>daemon</em>), solo podía manejar <span class="versalitas">pop</span> 3 y estaba escrito a la manera de un aficionado (Seung-Hong era un brillante programador pero no tenía experiencia, y ambas características eran palpables). El código de Carl era mejor, bastante profesional y robusto, pero su programa carecía de varias de las características importantes del Fetchpop que eran difíciles de implementar (incluyendo las que yo mismo había agregado).</p>
        <p>¿Seguía o cambiaba? Cambiar significaba desechar el código que había añadido a cambio de una mejor base de desarrollo.</p>
        <p>Un motivo práctico para cambiar fue la necesidad de contar con soporte de múltiples protocolos. <span class="versalitas">pop</span> 3 es el protocolo de servidor de correos que más se utiliza, pero no es el único. Ni Fetchpop ni otros manejaban <span class="versalitas">pop</span>2, R<span class="versalitas">pop</span> o A<span class="versalitas">pop</span>, y yo tenía ya la idea vaga de añadir el Protocolo de Acceso a Mensajes por Internet (<span class="versalitas">imap</span>) solo por entretenimiento.</p>
        <p>Pero había una razón más teórica para pensar que el cambio podía ser una buena idea, algo que aprendí mucho antes de Linux:</p>
        <blockquote id="afor3"><strong>3. «Contempla desecharlo; de todos modos tendrás que hacerlo».</strong></blockquote>
        <p>Diciéndolo de otro modo: no se entiende cabalmente un problema hasta que se implementa la primera solución. La siguiente ocasión quizá uno ya sepa lo suficiente para solucionarlo. Así que, si quieres resolverlo, disponte a empezar de nuevo al menos una vez.</p>
        <p>«Bien —me dije— los cambios a Fetchpop fueron un primer intento, así que cambio».</p>
        <p>Después de enviarle mi primera serie de mejoras a Carl Harris el 25 de junio de 1996, me enteré de que él había perdido el interés por Popclient desde hacía rato. El programa estaba un poco abandonado, polvoriento y con algunas pulgas menores colgando. Como se le tenían que hacer varias correcciones, pronto acordamos que lo más lógico era que yo asumiera el control del proyecto.</p>
        <p>Sin darme cuenta, el proyecto había alcanzado otras dimensiones. Ya no estaba intentando hacerle unos cuantos cambios menores a un cliente <span class="versalitas">pop</span>, sino que me había hecho responsable de uno y las ideas que bullían en mi cabeza me conducirían probablemente a cambios mayores.</p>
        <p>En una cultura del <em>software</em> que estimula a compartir el código fuente, esta era la forma natural de que el proyecto evolucionara. Yo actuaba de acuerdo con lo siguiente:</p>
        <blockquote id="afor4"><strong>4. Si tienes la actitud adecuada, encontrarás problemas interesantes.</strong></blockquote>
        <p>Pero la actitud de Carl Harris fue aún más importante. Él entendió que:</p>
        <blockquote id="afor5"><strong>5. Cuando se pierde el interés en un programa, el último deber es heredarlo a un sucesor competente.</strong></blockquote>
        <p>Sin siquiera discutirlo, Carl y yo sabíamos que el objetivo común era obtener la mejor solución. La única duda entre nosostros era si yo podía probar que el proyecto iba a quedar en buenas manos. Una vez que lo hice, él actuó de buena gana y con diligencia. Espero comportarme igual cuando llegue mi turno.</p>
        <h2>La importancia de contar con usuarios</h2>
        <p>Así es como heredé Popclient. Además, recibí su base de usuarios, lo cual fue igual o más importante. Tener usuarios es maravilloso. No solo porque prueban que uno está satisfaciendo una necesidad o que se ha hecho algo bien, sino porque, cultivados adecuadamente, pueden convertirse en magníficos asistentes.</p>
        <p>Otro aspecto importante de la tradición Unix, que Linux nuevamente lleva al límite, es que muchos de los usuarios son también <em>hackers</em>, y al estar disponible el código fuente se vuelven <em>hackers</em> muy efectivos. Esto puede resultar tremendamente útil para reducir el tiempo de depuración de los programas. Con un buen estímulo, los usuarios diagnosticarán problemas, sugerirán correcciones y ayudarán a mejorar los programas mucho más rápido de lo que uno lo haría sin ayuda.</p>
        <blockquote id="afor6"><strong>6. Tratar a los usuarios como colaboradores es la forma más apropiada de mejorar el código, y la más efectiva de depurarlo.</strong></blockquote>
        <p>Suele ser fácil subestimar el poder de este efecto. De hecho, muchos infravalorábamos la capacidad multiplicadora que se adquiere con el número de usuarios y que reduce la complejidad de los sistemas, hasta que Linus demostró lo contrario.</p>
        <p>En realidad considero que la genialidad de Linus no radica en la construcción misma del <em>kernel</em> de Linux, sino en la invención del modelo de desarrollo de Linux. Cuando en una ocasión expresé esta opinión delante de él, sonrió y repitió quedito una frase que ha dicho muchas veces: «Básicamente soy una persona muy floja a quien le gusta obtener el crédito por lo que realmente hacen los demás». Flojo como un zorro. O, como diría Robert Heinlein, demasiado flojo para fallar.</p>
        <p>En retrospectiva, un precedente de los métodos y el éxito que tiene Linux podría encontrarse en el desarrollo de las bibliotecas del Emacs <span class="versalitas">gnu</span>, así como los archivos del código de Lisp.&#160;En contraste con el estilo catedral de construcción del núcleo del Emacs escrito en C, y de muchas otras herramientas de la Free Software Foundation (<span class="versalitas">fsf</span>), la evolución del código de Lisp fue bastante fluida y, en general, dirigida por los propios usuarios. Las ideas y los prototipos de los modos se rescribían tres o cuatro veces antes de alcanzar su forma estable final, mientras que las frecuentes colaboraciones informales se hacían posibles gracias al internet, al estilo Linux.</p>
        <p>Es más, uno de mis programas con mayor éxito antes de Fetchmail fue probablemente el modo Version Control (<span class="versalitas">vc</span>) para Emacs, una colaboración tipo Linux, que realicé por correo electrónico conjuntamente con otras tres personas, de las cuales solamente he conocido a una (Richard Stallman) hasta la fecha. <span class="versalitas">vc</span> era una <em>frontend</em> para Source Code Control System (<span class="versalitas">sccs</span>), Revision Control System (<span class="versalitas">rcs</span>) y posteriormente Concurrent Versions System (<span class="versalitas">cvs</span>), que ofrecía operaciones de control de versiones de manera directa desde Emacs. Era el desarrollo de un pequeño y hasta cierto punto rudimentario modo <samp>sccs.el</samp> que alguien más había escrito. El desarrollo de <span class="versalitas">vc</span> tuvo éxito porque, a diferencia del Emacs mismo, el código de Emacs en Lisp podía pasar por el ciclo de publicación, prueba y depuración muy rápidamente.</p>
        <p>(Uno de los efectos colaterales de la política de la <span class="versalitas">fsf</span> de atar legalmente el código a la General Public License [<span class="versalitas">gpl</span>] fue su dificultad para usar el modo bazar, debido a la idea de que se debían de asignar derechos de autor por cada contribución individual de más de veinte líneas, con la finalidad de inmunizar el código protegido por la <span class="versalitas">gpl</span> de cualquier problema legal surgido de la ley de derechos de autor. Los usuarios de las licencias <span class="versalitas">bsd</span> o <span class="versalitas">mit</span> no tienen este problema, debido a que no intentan reservarse derechos que difícilmente alguien más intentaría poner en duda).</p>
        <h2>Libera rápido y a menudo</h2>
        <p>Las publicaciones rápidas y frecuentes del código constituyen una parte crítica del modelo Linux de desarrollo. La mayoría de los programadores (incluyéndome), creía antes que esta era una mala práctica para proyectos que no fueran triviales, debido a que las versiones de prueba, casi por definición, suelen estar plagadas de errores y a nadie le gusta agotar la paciencia de los usuarios.</p>
        <p>Esta idea reafirmaba la preferencia de los programadores por el estilo catedral de desarrollo. Si el objetivo principal era que los usuarios vieran la menor cantidad de errores, entonces solo había que liberar una vez cada seis meses (o aun con menos frecuencia) y trabajar como perro en la depuración de las versiones que salieran a la luz. El núcleo del Emacs escrito en C se desarrolló de esta forma. No así la biblioteca de Lisp, ya que los repositorios de sus archivos donde se podían conseguir versiones nuevas y en desarrollo del código, independientemente del ciclo de desarrollo del Emacs, estaban fuera del control de la <span class="versalitas">fsf</span>.</p>
        <p>El más importante de estos archivos fue el Elisp de la Universidad Estatal de Ohio, el cual se anticipó al espíritu y a muchas de las características de los grandes archivos actuales de Linux. Pero solamente algunos de nosotros reflexionamos realmente acerca de lo que estábamos haciendo, o de lo que la simple existencia del archivo sugería sobre los problemas implícitos en el modelo catedral de la <span class="versalitas">fsf</span>. Yo realicé un intento serio, alrededor de 1992, de unir formalmente buena parte del código de Ohio con la biblioteca Lisp oficial del Emacs. Me metí en problemas políticos muy serios y no tuve éxito.</p>
        <p>Pero un año después, a medida que Linux se agigantaba, quedó claro que estaba pasando algo distinto y mucho más sano. La política abierta de desarrollo de Linus era lo más opuesto a la construcción estilo catedral. Los repositorios de archivos en SunSITE y TSX-11 mostraban una intensa actividad y muchas distribuciones de Linux circulaban. Y todo esto se manejaba en la publicación de programas con una frecuencia que no tenía precedentes.</p>
        <p>Linus estaba tratando a sus usuarios como colaboradores de la forma más efectiva posible:</p>
        <blockquote id="afor7"><strong>7. Libera rápido. Libera a menudo. Y escucha a tus clientes.</strong></blockquote>
        <p>La innovación de Linus no consistió tanto en esto (algo parecido había venido sucediendo en la tradición del mundo Unix desde hacía tiempo), sino en llevarlo a un nivel de intensidad acorde a la complejidad de lo que estaba desarrollando. En ese entonces no era raro que liberara una nueva versión del <em>kernel</em> ¡más de una vez al día! Y, debido a que cultivó su base de desarrolladores y buscó colaboración en internet más intensamente que ningún otro, funcionó.</p>
        <p>¿Pero cómo fue que funcionó? ¿Era algo que yo podía emular o se debía a la genialidad única de Linus?</p>
        <p>No lo considero así. Está bien, Linus es un <em>hacker</em> endiabladamente astuto (¿cuántos de nosotros podríamos diseñar un <em>kernel</em> de alta calidad?). Pero Linux en sí no representa ningún salto conceptual sorprendente. Linus no es (al menos no hasta ahora) un genio innovador del diseño como lo son Richard Stallman o James Gosling. En realidad, para mí Linus es un genio de la ingeniería; tiene un sexto sentido para evitar los callejones sin salida en el desarrollo o la depuración, y es muy sagaz para encontrar el camino con el mínimo esfuerzo desde el punto A hasta el punto B. De hecho, todo el diseño de Linux transpira esta calidad y refleja un Linus conservador que simplifica el enfoque en el diseño.</p>
        <p>Por lo tanto, si las publicaciones frecuentes del código y la búsqueda de asistencia en internet no son accidentes, sino partes integrales del ingenio de Linus para ver la ruta crítica del mínimo esfuerzo, ¿qué era lo que estaba maximizando? ¿Qué era lo que estaba exprimiendo de la maquinaria?</p>
        <p>Planteada de esta forma, las pregunta se responde por sí sola. Linus estaba manteniendo a sus usuarios-<em>hackers</em>-colaboradores constantemente estimulados y recompensados por la perspectiva de tomar parte en la acción y satisfacer su ego, premiado con la exhibición y mejora constante, casi diaria, de su trabajo.</p>
        <p>Linus apostaba claramente a maximizar el número de horas por persona invertidas en la depuración y el desarrollo, a pesar del riesgo que corría de volver inestable el código y agotar a la base de usuarios si un error serio resultaba insondable. Linus se portaba como si creyera en algo como esto:</p>
        <blockquote id="afor8"><strong>8. Dada una base suficiente de colaboradores y <em>beta testers</em>, casi cualquier problema puede ser identificado rápidamente y su solución será obvia al menos para alguien.</strong></blockquote>
        <p>O, dicho de manera menos formal, «con muchas miradas, todos los errores saltarán a la vista». Esto lo he bautizado como la Ley de Linus.</p>
        <p>Mi formulación original rezaba que todo problema deberá ser transparente para alguien. Linus descubrió que las personas que entendían y las que resolvían un problema no eran necesariamente las mismas, ni siquiera en la mayoría de los casos. Decía que «alguien encuentra el problema y otro lo resuelve». Pero el punto está en que ambas cosas suelen suceder con gran rapidez.</p>
        <p>Aquí, pienso, subyace una diferencia esencial entre el estilo bazar y el catedral. En el enfoque estilo catedral de la programación, los errores y problemas de desarrollo son fenómenos truculentos, insidiosos y profundos. Generalmente toma meses de revisión exhaustiva para unos cuantos el alcanzar la seguridad de que han sido eliminados del todo. Por eso se dan los intervalos tan largos entre cada versión que se libera, al igual que la inevitable desmoralización cuando estas versiones, largamente esperadas, no resultan perfectas.</p>
        <p>En el enfoque de programación estilo bazar, por otro lado, se asume que los errores son fenómenos relativamente evidentes o, por lo menos, que pueden volverse relativamente evidentes cuando se exhiben a miles de desarrolladores entusiastas que colaboran en cada una de las versiones. En consecuencia, se libera con frecuencia para poder obtener una mayor cantidad de correcciones, logrando como efecto colateral benéfico el perder menos cuando un obstáculo se atraviesa.</p>
        <p>Y eso es todo. Con eso basta. Si la Ley de Linus fuera falsa, entonces cualquier sistema que sea lo suficientemente complejo, como el <em>kernel</em> de Linux que está siendo manipulado por tantos, debería haber colapsado en algún punto bajo el peso de ciertas interacciones imprevistas y errores «muy profundos» inadvertidos. Pero si es cierta, bastaría para explicar la relativa ausencia de errores en el código de Linux.</p>
        <p>Después de todo, esto no debe parecernos tan sorpresivo. Hace algunos años los sociólogos descubrieron que la opinión promedio de un numero grande de observadores igualmente expertos (o igualmente ignorantes) es más confiable de predecir que la de uno de los observadores seleccionado al azar. A esto se le conoce como el método Delphi. Al parecer, lo que Linus ha demostrado es que esto también es valedero en el ámbito de la depuración de un sistema operativo: que el método Delphi puede abatir la complejidad implícita en el desarrollo, incluso al nivel asociado al núcleo de un sistema operativo.</p>
        <p>Estoy en deuda con Jeff Dutky, quien me sugirió que la Ley de Linus puede replantearse diciendo que «la depuración puede hacerse en paralelo». Jeff señala que a pesar de que la depuración requiere que los participantes se comuniquen con un programador que coordina el trabajo, no demanda ninguna coordinación significativa entre ellos. Por lo tanto, no cae víctima de la asombrosa complejidad cuadrática ni de los costos de maniobra que ocasionan que la incorporación de desarrolladores resulte problemática.</p>
        <p>En la práctica, la pérdida teórica de eficiencia debido a la duplicación del trabajo por parte de los programadores casi nunca es un tema que revista importancia en el mundo Linux. Un efecto de la «política de liberar rápido y a menudo» es que esta clase de duplicaciones se minimizan al propagarse las correcciones rápidamente.</p>
        <p>Brooks hizo una observación relacionada con la de Jeff: «El costo total del mantenimiento de un programa muy usado es típicamente alrededor del cuarenta por ciento o más del costo del desarrollo. Sorpresivamente, este costo está fuertemente influenciado por el número de usuarios. <em>Más usuarios detectan una mayor cantidad de errores</em>». (El énfasis es mío).</p>
        <p>Una mayor cantidad de usuarios detecta más errores debido a que tienen diferentes maneras de evaluar el programa. Este efecto se incrementa cuando los usuarios son colaboradores. Cada uno se enfoca a la tarea de la caracterización de los errores con un bagaje conceptual y con instrumentos analíticos distintos, desde un ángulo diferente. El método Delphi parece funcionar precisamente debido a estas diferencias. En el contexto específico de la depuración, dichas diferencias también tienden a reducir la duplicación del trabajo.</p>
        <p>Por lo tanto, el agregar más <em>beta testers</em> podría no contribuir a reducir la complejidad del «más profundo» de los errores actuales, desde el punto de vista del desarrollador, pero aumenta la probabilidad de que la caja de herramientas de alguno de ellos se equipare al problema, de manera que esa persona vea claramente el error.</p>
        <p>Linus también dobla sus apuestas. En el caso de que realmente existan errores serios, las versiones del <em>kernel</em> de Linux son enumeradas de tal manera que los usuarios potenciales puedan escoger la última versión considerada como «estable» o ponerse al filo de la navaja y arriesgarse a los errores con tal de aprovechar las nuevas características. Esta táctica no ha sido formalmente imitada por la mayoría de los <em>hackers</em> de Linux, pero quizá deberían hacerlo. El hecho de contar con ambas opciones lo vuelve aun más atractivo.</p>
        <h2>¿Cuándo una rosa no es una rosa?</h2>
        <p>Después de estudiar la forma en que actuó Linus y de haber formulado una teoría sobre por qué tuvo éxito, tomé la decisión consciente de probarla en mi nuevo proyecto (el cual, debo admitirlo, es mucho menos complejo y ambicioso).</p>
        <p>Lo primero que hice fue reorganizar y simplificar Popclient. El trabajo de Carl Harris era muy bueno, pero exhibía una complejidad innecesaria, típica de muchos de los programadores en C. Él trataba el código como la parte central y las estructuras de datos como un apoyo para este. Como resultado, el código resultó muy elegante, pero el diseño de las estructuras de datos quedó descuidado y feo (por lo menos con respecto a los estándares exigentes de este viejo <em>hacker</em> de Lisp).</p>
        <p>Sin embargo, tenía otro motivo para rescribir, además de mejorar el diseño de la estructura de datos y el código: el proyecto debía evolucionar en algo que yo entendiera cabalmente. No es nada divertido ser el responsable de corregir los errores en un programa que no se entiende.</p>
        <p>Por lo tanto, durante el primer mes, o algo así, simplemente fui siguiendo los pormenores del diseño básico de Carl. El primer cambio serio que realicé fue agregar el soporte de <span class="versalitas">imap</span>. Lo hice reorganizando los administradores de protocolos en un administrador genérico con tres tablas de métodos (para <span class="versalitas">pop</span>2, <span class="versalitas">pop</span> 3 e <span class="versalitas">imap</span>). Este y algunos cambios anteriores muestran un principio general que es bueno que los programadores tengan en mente, especialmente los que programan en lenguajes tipo C y no manejan estructuras de datos dinámicas:</p>
        <blockquote id="afor9"><strong>9. Las estructuras de datos inteligentes y el código burdo funcionan mucho mejor que en el caso inverso.</strong></blockquote>
        <p>De nuevo Fred Brooks: «Muéstrame tu código y esconde tus estructuras de datos, y continuaré intrigado. Muéstrame tus estructuras de datos y generalmente no necesitaré ver tu código: resultará evidente».</p>
        <p>En realidad, él hablaba de «diagramas de flujo» y «tablas». Pero con treinta años de cambios terminológicos y culturales resulta prácticamente la misma idea.</p>
        <p>En este momento (a principios de septiembre de 1996, aproximadamente seis semanas después de haber comenzado) empecé a pensar que un cambio de nombre podría ser apropiado. Después de todo, ya no se trataba de un simple cliente <span class="versalitas">pop</span>. Pero todavía vacilé, debido a que no había nada nuevo y genuinamente mío en el diseño. Mi versión de Popclient aún tenía que desarrollar una identidad propia.</p>
        <p>Esto cambió radicalmente cuando Fetchmail aprendió a remitir el correo recibido al puerto del protocolo para transferencia simple de correo (<span class="versalitas">smtp</span>). Volveré a este punto en un momento. Primero quiero decir lo siguiente: yo afirmé anteriormente que decidí utilizar este proyecto para probar mi teoría sobre qué había hecho bien Linus Torvalds. ¿Cómo lo hice?, podrían ustedes preguntar. Fue de la siguiente manera:</p>
        <ol>
            <li><p>Liberaba rápido y a menudo (casi nunca dejé de hacerlo en periodos menores a diez días; durante las etapas de desarrollo intenso, una vez al día).</p></li>
            <li><p>Ampliaba mi lista de analistas de versiones beta o <em>beta testers</em>, incorporando a toda persona que me contactara para saber sobre Fetchmail.</p></li>
            <li><p>Efectuaba anuncios espectaculares a esta lista cada vez que liberaba una nueva versión, estimulando a la gente a participar.</p></li>
            <li><p>Y escuchaba a mis <em>beta testers</em>, consultándoles decisiones referentes al diseño y tomándolos en cuenta cuando me mandaban sus mejoras o retroalimentación.</p></li>
        </ol>
        <p>La recompensa por estas simples medidas fue inmediata. Desde el principio del proyecto obtuve reportes de errores de calidad, frecuentemente con buenas soluciones anexas que envidiarían la mayoría de los desarrolladores. Obtuve crítica constructiva, mensajes de admiradores e inteligentes sugerencias. Lo que lleva a la siguiente lección:</p>
        <blockquote id="afor10"><strong>10. Si tratas a tus analistas (<em>beta testers</em>) como si fueran tu recurso más valioso, ellos te responderán convirtiéndose en tu recurso más valioso.</strong></blockquote>
        <p>Una medida interesante del éxito de Fetchmail fue el tamaño de la lista de analistas beta del proyecto, los amigos de Fetchmail. Cuando escribí esto tenía 249 miembros y se sumaban entre dos o tres semanalmente.</p>
        <p>Revisándola hoy, a finales de mayo de 1997, la lista ha comenzando a perder miembros debido a una razón sumamente interesante. Varias personas me han pedido que las dé de baja debido a que Fetchmail les está funcionando tan bien ¡que ya no necesitan ver todo el tráfico de la lista! A lo mejor esto es parte del ciclo vital normal de un proyecto maduro, realizado por el método de construcción estilo bazar.</p>
        <h2>Popclient se convierte en Fetchmail</h2>
        <p>El momento crucial para el proyecto fue cuando Harry Hochheiser me mandó su código fuente para incorporar la remisión del correo recibido a la máquina cliente a través del puerto <span class="versalitas">smtp</span>. Comprendí casi inmediatamente que una implementación adecuada de esta característica iba a dejar todos los demás métodos a un paso de ser obsoletos.</p>
        <p>Durante muchas semanas había estado perfeccionando Fetchmail, agregándole características a pesar de que sentía que el diseño de la interfaz era útil pero algo burdo, poco elegante y con demasiadas opciones insignificantes colgando fuera de lugar. La facilidad de vaciar el correo recibido a un buzón de correos o la salida estándar me incomodaba de cierta manera, pero no alcanzaba a comprender por qué.</p>
        <p>Lo que advertí cuando me puse a pensar sobre la expedición del correo por el <span class="versalitas">smtp</span> fue que Popclient estaba intentando hacer demasiadas cosas juntas. Había sido diseñado para funcionar al mismo tiempo como un agente de transporte (<span class="versalitas">mta</span>) y un agente de entrega (<span class="versalitas">mda</span>). Con la remisión del correo por el <span class="versalitas">smtp</span> podría abandonar la función de <span class="versalitas">mda</span> y centrarme solamente en la de <span class="versalitas">mta</span>, mandando el correo a otros programas para su entrega local, justo como lo hace Sendmail.</p>
        <p>¿Por qué sufrir con toda la complejidad de configurar el agente de entrega o realizar un bloqueo y luego añadirlo al final del buzón de correos, cuando el puerto&#160;25 está garantizado casi en toda plataforma con soporte <span class="versalitas">tcp/ip</span>? Especialmente cuando esto significa que el correo obtenido de esta manera tiene garantizado verse como un correo que ha sido transferido de manera normal por el <span class="versalitas">smtp</span>, que es lo que realmente queremos.</p>
        <p>De aquí se extraen varias lecciones. Primero, la idea de enviar por el puerto <span class="versalitas">smtp</span> fue la mayor recompensa individual que obtuve al tratar de emular conscientemente los métodos de Linus. Un usuario me proporcionó una fabulosa idea y lo único que restaba era comprender sus implicaciones.</p>
        <blockquote id="afor11"><strong>11. Lo más grande, después de tener buenas ideas, es reconocer las buenas ideas de tus usuarios. Esto último es a veces lo mejor.</strong></blockquote>
        <p>Lo que resulta muy interesante es que uno rápidamente encontrará que, cuando está absolutamente convencido y seguro de lo que le debe a los demás, entonces el mundo lo tratará como si hubiera realizado cada parte de la invención por sí mismo, y esto le hará apreciar con modestia su ingenio natural. ¡Todos podemos ver lo bien que funcionó esto para el propio Linus!</p>
        <p>(Cuando leía este documento en la Conferencia de Perl de agosto de 1997, Larry Wall estaba en la fila del frente. Al llegar a lo que acabo de decir, Larry dijo con voz alta: «¡Anda, di eso, díselos, hermano!». Todos los presentes rieron porque sabían que eso también le había funcionado muy bien al inventor de Perl).</p>
        <p>Y a unas cuantas semanas de haber echado a andar el proyecto con el mismo espíritu comencé a recibir adulaciones similares; no solo de parte de mis usuarios, sino de otras personas que se habían enterado por terceros. He puesto a buen recaudo parte de esos correos. Los volveré a leer en alguna ocasión, si es que me llego a preguntar si mi vida ha valido la pena. <samp>:-)</samp></p>
        <p>Pero hay otras dos lecciones más fundamentales, que no tienen que ver con las políticas, que son generales para todos los tipos de diseño:</p>
        <blockquote id="afor12"><strong>12. Frecuentemente, las soluciones más innovadoras y espectaculares surgen al darte cuenta de que la concepción del problema era errónea.</strong></blockquote>
        <p>Había estado intentando resolver el problema equivocado al continuar desarrollando Popclient como un agente de entrega y de transporte, con toda clase de modos raros de entrega local. El diseño de Fetchmail requería ser repensado de arriba abajo como un agente de transporte puro: como eslabón, si se habla de <span class="versalitas">smtp</span>, de la ruta normal que sigue el correo en internet.</p>
        <p>Cuando te topas con un muro durante el desarrollo —cuando te resulta difícil pensar mas allá de la siguiente corrección— es, a menudo, la hora de preguntarse no tanto si realmente se tiene la respuesta correcta, sino si se está planteando la pregunta correcta. Quizá el problema requiere ser replanteado.</p>
        <p>Bien, yo ya había replanteado mi problema. Evidentemente, lo que tenía que hacer ahora era: 1) programar el soporte de envío por <span class="versalitas">smtp</span> en el controlador genérico, 2) convertirlo en el modo por omisión y 3) eliminar eventualmente todas las demás modalidades de entrega, especialmente las de envío a buzón y a la salida estándar.</p>
        <p>Estuve, durante algún tiempo, titubeando para dar el tercer paso; temiendo trastornar a los viejos usuarios de Popclient, quienes dependían de estos mecanismos alternativos de entrega. En teoría, ellos podían cambiar inmediatamente a archivos <samp>.forward</samp> o sus equivalentes en otro esquema que no fuera Sendmail para obtener los mismos resultados. Pero, en la práctica, la transición podría complicarse demasiado.</p>
        <p>Cuando por fin lo hice, los beneficios fueron inmensos. Las partes más intrincadas del código del controlador desaparecieron. La configuración se volvió radicalmente más simple: al no tratar con el <span class="versalitas">mda</span> del sistema ni con el buzón del usuario, ya no había que preocuparse de que el sistema operativo soportara el bloqueo de archivos.</p>
        <p>Asimismo, el único riesgo de extraviar correo también se había desvanecido. Antes, si especificabas el envío a un buzón y el disco estaba lleno, entonces el correo se perdía irremediablemente. Esto no pasa con el envío vía <span class="versalitas">smtp</span>, debido a que el <span class="versalitas">smtp</span> del receptor no devolverá un <samp>OK</samp> mientras el mensaje no haya sido entregado con éxito o al menos mandado a la cola para su entrega ulterior.</p>
        <p>Además, el desempeño mejoró mucho (aunque uno no lo notara en la primera corrida). Otro beneficio nada despreciable fue la simplificación de la página del manual.</p>
        <p>Más adelante hubo que agregar la entrega a un agente local especificado por el usuario con el fin de manejar algunas situaciones oscuras involucradas con la asignación dinámica de direcciones en <span class="versalitas">slip</span>. Sin embargo, encontré una forma mucho más simple de hacerlo.</p>
        <p>¿Cuál era la moraleja? No hay que vacilar en desechar alguna característica superflua si puedes hacerlo sin pérdida de efectividad. Antoine de Saint-Exupery (aviador y diseñador aeronáutico, cuando no se dedicaba a escribir libros clásicos para niños) afirmó que:</p>
        <blockquote id="afor13"><strong>13. «La perfección —en diseño— se alcanza no cuando ya no hay nada que agregar, sino cuando ya no hay algo que quitar».</strong></blockquote>
        <p>Cuando el código va mejorando y se va simplificando es cuando sabes que estás en lo correcto. Así, en este proceso, el diseño de Fetchmail adquirió una identidad propia, diferente de su ancestro, Popclient.</p>
        <p>Había llegado la hora de cambiar de nombre. El nuevo diseño parecía más un doble del Sendmail que del viejo Popclient; ambos eran <span class="versalitas">mta</span>, agentes de transporte, pero mientras que Sendmail empuja y luego entrega, el nuevo Popclient acarrea y después entrega. Así que, después de dos arduos meses, lo bauticé de nuevo con el nombre de Fetchmail.</p>
        <h2>El crecimiento de Fetchmail</h2>
        <p>Allí me encontraba con un bonito e innovador diseño, un programa cuyo funcionamiento tenía asegurado gracias al uso diario y al equipo de <em>beta testers</em>. Esta gradualmente me hizo ver que ya no estaba involucrado en un <em>hackeo</em> personal y trivial que podía resultar útil para unas cuantas personas más. Tenía en mis manos un programa que cualquier <em>hacker</em>, con una caja Unix y una conexión <span class="versalitas">slip</span> o <span class="versalitas">ppp</span>, realmente necesita.</p>
        <p>Cuando el método de expedición por <span class="versalitas">smtp</span> se puso delante de la competencia, se convirtió en un «matón profesional», uno de esos programas clásicos que ocupa tan bien su lugar que las otras alternativas no solo son descartadas, sino olvidadas.</p>
        <p>Pienso que uno realmente no podría imaginar o planear un resultado como este. Tienes que meterte a manejar conceptos de diseño tan poderosos que posteriormente los resultados parezcan inevitables, naturales o incluso predestinados. La única manera de hacerse de estas ideas es jugar con un montón de propuestas o tener una visión de la ingeniería lo suficientemente competente como para poder llevar las buenas ideas de otras personas más allá de lo que estas pensaban que podían llegar.</p>
        <p>Andrew Stuart Tanenbaum tuvo una buena idea original con la construcción de un Unix nativo y simple que sirviera como herramienta de enseñanza para computadoras con microprocesador 386. Linus Torvalds llevó el concepto de Minix más allá de lo que Andrew imaginó que pudiera llegar y se transformó en algo maravilloso. De la misma manera (aunque en una escala menor), tomé algunas ideas de Carl Harris y Harry Hochheiser y las impulsé fuertemente. Ninguno de nosotros era «original» en el sentido romántico de la idea que se tiene de un genio. Pero la mayor parte del desarrollo de la ciencia, la ingeniería y el <em>software</em> no se debe a un genio original, sino a la mitología del <em>hacker</em>, por el contrario.</p>
        <p>Los resultados fueron siempre un tanto complicados: de hecho, ¡justo el tipo de reto para el que vive un <em>hacker</em>! Y esto implicaba que tenía que fijar aún más alto mis propios estándares. Para lograr que Fetchmail fuese tan bueno como ahora veía que podía ser, tenía que escribir no solo para satisfacer mis propias necesidades, sino también incluir y dar el soporte a otros que estuvieran fuera de mi órbita. Y esto lo tenía que hacer manteniendo el programa sencillo y robusto.</p>
        <p>La primera característica más importante y contundente que escribí después de hacer eso fue el soporte para recabado múltiple; esto es, la capacidad de recoger el correo de los buzones que habían acumulado todo el correo de un grupo de usuarios y luego trasladar cada mensaje al recipiente individual del respectivo destinatario.</p>
        <p>En parte, decidí agregar el soporte de recabado múltiple debido a que algunos usuarios lo reclamaban, pero sobre todo porque evidenciaría los errores de un código de recabado individual, al forzarme a abordar el direccionamiento con generalidad. Tal como ocurrió. Poner el <span class="versalitas">rfc</span>&#160;822 a que funcionara correctamente me tomó bastante tiempo, no solo porque cada una de las partes que lo componen son difíciles, sino porque involucraban un montón de detalles confusos e interdependientes entre sí.</p>
        <p>Así, el direccionamiento del recabado múltiple se volvió una excelente decisión de diseño. De esta forma supe que:</p>
        <blockquote id="afor14"><strong>14. Toda herramienta debe resultar útil en la forma prevista, pero una gran herramienta te permite usarla de la manera menos esperada.</strong></blockquote>
        <p>El uso inesperado del recabado múltiple de Fetchmail fue el trabajar las listas de correo con la lista guardada y realizar la expansión del alias en el lado del cliente de la conexión <span class="versalitas">slip</span> o <span class="versalitas">ppp</span>. Esto significa que alguien que cuenta con una computadora y una cuenta <span class="versalitas">isp</span> puede manejar una lista de correos sin que tenga que continuar entrando a los archivos del alias del <span class="versalitas">isp</span>.</p>
        <p>Otro cambio importante reclamado por mis <em>beta testers</em> era el soporte para las extensiones multipropósito de correo de internet (<span class="versalitas">mime</span>) de 8&#160;bits. Esto se podía obtener fácilmente, ya que había sido cuidadoso en mantener el código de 8&#160;bits limpio. No es que yo me hubiera anticipado a la exigencia de esta característica, sino que obedecía a otra regla:</p>
        <blockquote id="afor15"><strong>15. Cuando se escribe <em>software</em> para una puerta de enlace de cualquier tipo, hay que tomar la precaución de alterar el flujo de datos lo menos posible, y ¡nunca eliminar información a menos que los receptores obliguen a hacerlo!</strong></blockquote>
        <p>Si no hubiera obedecido esta regla, entonces el soporte <span class="versalitas">mime</span> de 8&#160;bits habría resultado difícil y lleno de errores. De tal modo, todo lo que tuve que hacer fue leer el <span class="versalitas">rfc</span>&#160;1652 y agregar algo de lógica trivial en la generación de encabezados.</p>
        <p>Algunos usuarios europeos me presionaron para que introdujera una opción que limitase el número de mensajes acarreados por sesión (de manera que pudieran controlar los costos de sus caras redes telefónicas). Me opuse a dicho cambio durante mucho tiempo y aun no estoy totalmente conforme con él. Pero si escribes para el mundo debes escuchar a tus clientes: esto no debe cambiar en nada solo porque no te están dando dinero.</p>
        <h2>Algunas lecciones más extraídas de Fetchmail</h2>
        <p>Antes de volver a los temas generales de ingeniería de <em>software</em>, hay que ponderar otras dos lecciones específicas sacadas de la experiencia de Fetchmail.</p>
        <p>La sintaxis de los archivos <span class="versalitas">rc</span> incluye una serie de palabras clave que pueden ser consideradas como «ruido» y son ignoradas por el analizador. La sintaxis inglesa que estas permiten es considerablemente más legible que la secuencia de los pares clave-valor tradicionales que obtienes cuando las quitas.</p>
        <p>Estas comenzaron como un experimento de madrugada, cuando noté que muchas de las declaraciones de los archivos <span class="versalitas">rc</span> se asemejaban un poco a un minilenguaje imperativo. (Esta también fue la razón por la cual cambié la palabra clave original de Popclient de «servidor» a «poll»).</p>
        <p>Me parecía en ese entonces que aproximar ese minilenguaje imperativo al inglés lo podía hacer más fácil de usar. Ahora, a pesar de que soy un partidario convencido de la escuela de diseño «hágalo un lenguaje», ejemplificada en Emacs, <span class="versalitas">html</span> y muchas bases de datos, no soy normalmente un fanático de la sintaxis inglesa.</p>
        <p>Los programadores han tendido a favorecer tradicionalmente la sintaxis de control debido a que es muy precisa y compacta, además de no tener redundancia alguna. Esto es una herencia cultural de la época en que los recursos de cómputo eran muy caros, por lo que la etapa de análisis tenía que ser la más sencilla y económica posible. El inglés, con un cincuenta por ciento de redundancia, parecía ser un modelo muy inapropiado en ese entonces.</p>
        <p>Esta no es la razón por la cual yo dudo de la sintaxis inglesa; solo la menciono aquí para negarla. Con los ciclos baratos, la fluidez no debe ser un fin por sí misma. Ahora es más importante para un lenguaje el ser conveniente para los humanos que ser económico en términos de recursos computacionales.</p>
        <p>Sin embargo, hay razones suficientes para andar con cuidado. Una es el costo de la complejidad de la etapa de análisis: nadie quiere incrementarlo a un punto tal que se vuelva una fuente importante de errores y de confusión para el usuario. Otra radica en que al implementar una sintaxis inglesa para el lenguaje se exige con frecuencia que se deforme considerablemente el «inglés» inicial, por lo que la semejanza superficial con un lenguaje natural es tan confusa como podría haberlo sido la sintaxis tradicional. (Puedes ver mucho de esto en los lenguajes de programación de cuarta generación o <span class="versalitas">4gl</span> y en los lenguajes de búsqueda en bancos de datos comerciales).</p>
        <p>La sintaxis de control de Fetchmail parece esquivar estos problemas debido a que el dominio de su lenguaje es extremadamente restringido. Está muy lejos de ser un lenguaje de uso amplio; las cosas que dice no son muy complicadas, por lo que hay pocas posibilidades de confusión al moverse de un reducido subconjunto del inglés y el lenguaje de control real. Creo que se puede extraer una lección más general de esto:</p>
        <blockquote id="afor16"><strong>16. Cuando tu lenguaje está lejos de un Turing completo, entonces puedes endulzar tu sintaxis.</strong></blockquote>
        <p>Otra lección trata de la seguridad por obscuridad: recurrir al secreto para proteger ciertos datos. Algunos usuarios de Fetchmail me solicitaron cambiar el <em>software</em> para poder guardar las claves de acceso encriptadas en su archivo <span class="versalitas">rc</span>, de tal manera que los <em>crackers</em> no pudieran verlas por pura casualidad.</p>
        <p>No lo hice debido a que esto prácticamente no proporcionaría ninguna protección adicional. Cualquiera que adquiera los permisos necesarios para leer el archivo <span class="versalitas">rc</span> respectivo sería de todos modos capaz de correr Fetchmail y, si por su <em>password</em> fuera, podría sacar el decodificador necesario del mismo código de Fetchmail para obtenerlo.</p>
        <p>Todo lo que la encriptación de <em>password</em> en el archivo <samp>.fetchmailrc</samp> podría haber conseguido era una falsa sensación de seguridad para la gente que no está muy metida en este medio. La regla general es la siguiente:</p>
        <blockquote id="afor17"><strong>17. Un sistema de seguridad es tan seguro como secreto. Cuídate de los secretos a medias.</strong></blockquote>
        <h2>Condiciones necesarias para el modelo bazar</h2>
        <p>Los primeros que leyeron este documento, y las primeras versiones inacabadas que se hicieron públicas, preguntaban constantemente sobre los requisitos necesarios para un desarrollo exitoso dentro del modelo bazar, incluyendo la calificación del líder del proyecto, así como la del estado del código cuando uno va a hacerlo público y a comenzar a construir una comunidad de codesarrolladores.</p>
        <p>Está claro que uno no puede partir de cero en el modelo bazar. Con él, uno puede probar, buscar errores, poner a punto y mejorar algo, pero sería muy difícil originar un proyecto de un modo semejante al bazar. Linus no lo intentó de esta manera. Yo tampoco lo hice así. Nuestra naciente comunidad de desarrolladores necesita algo que ya corra para jugar.</p>
        <p>Cuando uno comienza la construcción del edificio comunal, lo que debe ser capaz de hacer es presentar una promesa plausible. El programa no necesita ser particularmente bueno. Puede ser burdo, tener muchos errores, estar incompleto y pobremente documentado. Pero en lo que no se puede fallar es en convencer a los potenciales codesarrolladores de que el programa puede evolucionar hacia algo elegante en el futuro.</p>
        <p>Linux y Fetchmail se hicieron públicos con diseños básicos, fuertes y atractivos. Mucha gente piensa que el modelo bazar ha considerado correctamente esto como crítico, para después saltar a la conclusión de que es indispensable que el líder del proyecto tenga un mayor nivel de intuición para el diseño y mucha capacidad.</p>
        <p>Sin embargo, Linus obtuvo su diseño a partir de Unix. Yo inicialmente conseguí el mío del antiguo Popmail (a pesar de que cambiaría mucho posteriormente, mucho más, guardando las proporciones, de lo que lo ha hecho Linux). Entonces, ¿es necesario que el líder o coordinador posea realmente un talento extraordinario en el modelo bazar o basta con que aproveche el talento de otros para el diseño?</p>
        <p>Creo que no es indispensable que quien coordine sea capaz de originar diseños de calidad excepcional, pero lo que sí es absolutamente esencial es que él o ella sea capaz de reconocer las buenas ideas de los demás sobre diseño.</p>
        <p>Tanto el proyecto de Linux como el de Fetchmail dan evidencias de esto. A pesar de que Linus no es un diseñador original espectacular (como lo discutimos anteriormente), ha mostrado tener una poderosa habilidad para reconocer un buen diseño e integrarlo al <em>kernel</em> de Linux. Ya he descrito cómo la idea de diseño de mayor envergadura para Fetchmail (reenvío por <span class="versalitas">smtp</span>) provino de otro.</p>
        <p>Los primeros lectores de este artículo&#160;me halagaron al sugerir que soy propenso a subestimar la originalidad del diseño en los  proyectos  bazar porque yo tengo mucha, y en consecuencia la tomo por sentada. En parte puede ser verdad: el diseño es ciertamente mi fuerte (comparado con la programación o la depuración).</p>
        <p>Pero el problema de ser listo y original en el diseño de <em>software</em> es que se tiende a convertir en hábito: uno hace las cosas como por reflejo, de manera tal que parezcan elegantes y complicadas, cuando debería mantenerlas simples y robustas. Ya he sufrido tropiezos en proyectos debido a esta equivocación, pero me las ingenié para que no sucediera lo mismo con Fetchmail.</p>
        <p>Así, pues, considero que el proyecto de Fetchmail tuvo éxito en parte debido a que contuve mi propensión a ser astuto; este es un argumento que va (por lo menos) contra la originalidad en el diseño como algo esencial para que los proyectos bazar sean exitosos. Consideremos de nuevo Linux. Supóngase que Linus Torvalds hubiera estado tratando de desechar innovaciones fundamentales en el diseño del sistema operativo durante la etapa de desarrollo; ¿podría acaso ser tan estable y exitoso como el <em>kernel</em> que tenemos?</p>
        <p>Por supuesto, se necesita un cierto nivel mínimo de habilidad para el diseño y la escritura de programas, pero es de esperar que cualquiera que quiera seriamente lanzar un esfuerzo al estilo bazar ya esté por encima de este nivel. El mercado interno de la comunidad de <em>software</em> libre, por reputación, ejerce una presión sutil sobre la gente para que no inicie esfuerzos de desarrollo que no sea capaz de mantener. Hasta ahora, esto parece estar funcionando bastante bien.</p>
        <p>Existe otro tipo de habilidad que no está asociada normalmente con el desarrollo de <em>software</em>, la cual yo considero igual de importante que el ingenio en el diseño para los proyectos bazar y a veces hasta más. Un coordinador o líder de proyecto estilo bazar debe tener buena capacidad de comunicación.</p>
        <p>Esto podría parecer obvio. Para poder construir una comunidad de desarrollo se necesita atraer gente, interesarla en lo que se está haciendo y mantenerla a gusto con el trabajo que se está desarrollando. El entusiasmo técnico constituye una buena parte para poder lograr esto, pero está muy lejos de ser definitivo. Además, es importante la personalidad que uno proyecta.</p>
        <p>No es una coincidencia que Linus sea un tipo que hace que la gente lo aprecie y desee ayudarle. Tampoco es una coincidencia que yo sea un extrovertido incansable que disfruta de trabajar con una muchedumbre o que tenga un poco de porte e instintos de cómico improvisado. Para hacer que el modelo bazar funcione ayuda mucho tener al menos un poco de capacidad para las relaciones sociales.</p>
        <h2>El contexto social del <em>software</em> libre</h2>
        <p>Bien se ha dicho: los mejores <em>hackeos</em> comienzan como soluciones personales a los problemas cotidianos del autor y se vuelven populares debido a que el problema es común para un buen grupo de usuarios. Esto nos hace regresar al tema del aforismo&#160;1, que quizá puede replantearse de una manera más útil:</p>
        <blockquote id="afor18"><strong>18. Para resolver un problema interesante, comienza por encontrar un problema que te resulte interesante.</strong></blockquote>
        <p>Así ocurrió con Carl Harris y el antiguo Popclient, y así sucede conmigo y Fetchmail. Esto, sin embargo, se ha entendido desde hace mucho. El punto interesante, que las historias de Linux y Fetchmail nos piden enfocar, está en la siguiente etapa: en la de la evolución del <em>software</em> en presencia de una amplia y activa comunidad de usuarios y codesarrolladores.</p>
        <p>En <em>The mythical man-month</em>, Fred Brooks observó que el tiempo del programador no es un consumible más; que el agregar desarrolladores a un proyecto maduro de <em>software</em> lo vuelve tardío. Expuso que la complejidad y los costos de comunicación de un proyecto aumentan al cuadrado el número de desarrolladores, mientras que el trabajo crece solo linealmente. A este planteamiento se le conoce como la Ley de Brooks y es generalmente aceptado como algo cierto. Pero si la Ley de Brooks fuese general, entonces Linux sería imposible.</p>
        <p>Unos años después, el clásico de Gerald Weinberg, <em>The psychology of computer programming</em>, plantea, visto en retrospectiva, una corrección esencial a Brooks. En su discusión sobre la «programación sin ego», Weinberg señala que los lugares donde los desarrolladores no tienen propiedad sobre su código, estimulando a otras personas a buscar errores y posibles mejoras, son los lugares donde el avance es dramáticamente más rápido que en cualquier otro lado.</p>
        <p>La terminología empleada por Weinberg ha evitado quizá que su análisis gane la aceptación que merece: uno tiene que sonreír al escuchar que los <em>hackers</em> de internet no tienen ego. Creo, no obstante, que su argumentación parece más válida ahora que nunca.</p>
        <p>La historia de Unix debió habernos preparado para lo que hemos aprendido de Linux (y lo que he verificado experimentalmente en una escala más reducida al copiar deliberadamente los métodos de Linus). Esto es: mientras que la creación de programas sigue siendo esencialmente una actividad solitaria, los desarrollos realmente grandes surgen de la atención y la capacidad de pensamiento de comunidades enteras. El desarrollador que usa solamente su cerebro sobre un proyecto cerrado se está quedando atrás del que sabe crear en un contexto abierto y evolutivo, en el que la búsqueda de errores y las mejoras son realizadas por cientos de personas.</p>
        <p>Pero el mundo tradicional de Unix no pudo llevar este enfoque hasta sus últimas consecuencias debido a varios factores. Uno era el conjunto de limitaciones legales producidas por varias licencias, secretos e intereses comerciales. Otra (en retrospectiva) era que el internet no había madurado lo suficiente para lograrlo.</p>
        <p>Antes de que el internet fuera tan accesible, había comunidades geográficamente compactas en las cuales la cultura estimulaba la «programación sin ego» de Weinberg y el desarrollador podía atraer fácilmente a muchos desarrolladores y usuarios capacitados. El Bell Labs, el MIT AI Lab y la Universidad de California en Berkeley son lugares donde se originaron innovaciones que son legendarias y aún poderosas.</p>
        <p>Linux fue el primer proyecto que se esforzó de forma consciente y exitosa en usar el mundo entero como un nido de talento. No creo que sea coincidencia que el periodo de gestación de Linux haya coincidido con el nacimiento de la World Wide Web o que Linux haya dejado su infancia durante el mismo periodo (1993-1994) en el que se vio el despegue de la industria <span class="versalitas">isp</span> y la explosión del interés masivo por el internet. Linus fue el primero que aprendió a jugar con las nuevas reglas que ese internet penetrante hace posibles.</p>
        <p>A pesar de que el internet barato era una condición necesaria para que evolucionara el modelo de Linux, no creo que fuera en sí misma una condición suficiente. Otros factores vitales fueron el desarrollo de un estilo de liderazgo y el arraigo de hábitos cooperativos, que permiten a los programadores atraer más codesarrolladores y obtener el máximo provecho del medio.</p>
        <p>Pero ¿cómo son ese estilo de liderazgo y esos hábitos? No pueden estar basados en relaciones de poder; aunque lo estuvieran, el liderazgo por coerción no produciría los resultados que estamos viendo. Weinberg cita un pasaje de la autobiografía del anarquista ruso del siglo&#160;<span class="versalitas">xix</span>, Kropotkin: <em>Memorias de un revolucionario</em>, que está muy acorde con este tema:</p>
        <blockquote>Habiendo sido criado en una familia que tenía siervos, me incorporé a la vida activa, como todos los jóvenes de mi época, con una gran confianza en la necesidad de mandar, ordenar, regañar, castigar y cosas semejantes. Pero cuando en una etapa temprana tuve que manejar empresas serias y tratar con personas libres, cuando cada error podría acarrear serias consecuencias, comencé a apreciar la diferencia entre actuar con base en el principio de orden y disciplina, y actuar con base en el principio del entendimiento. El primero funciona admirablemente en un desfile militar pero no sirve en la vida real, cuando el objetivo solo puede lograrse mediante el esfuerzo serio de muchas voluntades convergentes.</blockquote>
        <p>El «esfuerzo serio de muchas voluntades convergentes» es precisamente lo que todo proyecto estilo Linux requiere, mientras que el «principio de orden y disciplina» es efectivamente imposible de aplicar a los voluntarios del paraíso anarquista que llamamos internet. Para poder trabajar y competir de manera efectiva, los <em>hackers</em> que quieran encabezar proyectos de colaboración deben aprender a reclutar y entusiasmar a las comunidades de un modo vagamente sugerido por el «principio del entendimiento mutuo» de Kropotkin. Deben aprender a usar la Ley de Linus.</p>
        <p>Anteriormente me referí al método Delphi como una posible explicación de la Ley de Linus. Pero existen analogías más fuertes con sistemas adaptativos en biología y economía que se sugieren irresistiblemente. El mundo de Linux se comporta en muchos aspectos como el libre mercado o un sistema ecológico, donde un grupo de agentes individualistas buscan maximizar la utilidad en la que los procesos generan un orden espontáneo autocorrectivo más desarrollado y eficiente que lo que podría lograr cualquier tipo de planeación centralizada. Esta es entonces la manera de ver el «principio del entendimiento mutuo».</p>
        <p>La «función de utilidad» que los <em>hackers</em> de Linux están maximizando no es económica en el sentido clásico, sino algo intangible como la satisfacción de su ego y su reputación entre otros <em>hackers</em>. (Uno podría hablar de su «motivación altruista», pero ignoraríamos el hecho de que el altruismo en sí mismo es una forma de satisfacción del ego). Los grupos voluntarios que realmente funcionan de esta manera no son escasos; uno en el que he participado es el de aficionados a la ciencia ficción que, a diferencia del mundo de los <em>hackers</em>, reconoce explícitamente el <em>egoboo</em> (<em>ego boosting</em>, el realce de la reputación de uno entre los demás) como la motivación básica que está detrás de la actividad voluntaria.</p>
        <p>Linus, al ponerse exitosamente como vigía de un proyecto en el que el desarrollo es realizado por otros y al alimentar el interés en él hasta que se hizo autosustentable, ha mostrado el largo alcance del «principio del entendimiento mutuo» de Kropotkin. Este enfoque cuasieconómico del mundo de Linux nos permite ver cuál es la función de tal entendimiento.</p>
        <p>Podemos ver el método de Linus como la forma de crear un mercado eficiente en torno al <em>egoboo</em>, que liga el individualismo de los <em>hackers</em> a objetivos difíciles que solo se pueden lograr con la cooperación sostenida. Con el proyecto de Fetchmail he demostrado (en una escala mucho menor, claro) que sus métodos pueden copiarse con buenos resultados. Posiblemente lo mío fue realizado de una forma un poco más consciente y sistemática que la de él.</p>
        <p>Muchas personas (especialmente aquellas que desconfían políticamente del libre mercado) podrían esperar que una cultura de individuos egoístas que se dirigen solos sea fragmentaria, territorial, clandestina y hostil. Pero esta idea es claramente refutada, por ejemplo, por la asombrosa variedad, calidad y profundidad de la documentación de Linux. Se da por hecho que los programadores odian la documentación: ¿cómo entonces los <em>hackers</em> de Linux generan tanta? Evidentemente, el libre mercado de Linux basado en el <em>egoboo</em> funciona mejor para producir tal virtuosismo que los departamentos de edición, masivamente subsidiados, de los productores comerciales de <em>software</em>.</p>
        <p>Tanto el proyecto de Fetchmail como el del <em>kernel</em> de Linux han demostrado que, con el estímulo apropiado al ego de otros <em>hackers</em>, un desarrollador o coordinador fuerte puede usar el internet para aprovechar los beneficios de contar con un gran número de codesarrolladores, sin que se corra el peligro de desbocar el proyecto en un auténtico relajo. Por lo tanto, a la Ley de Brooks yo le contrapongo lo siguiente:</p>
        <blockquote id="afor19"><strong>19. Si el coordinador de desarrollo tiene un medio al menos tan bueno como lo es el internet y sabe dirigir sin coerción, muchas cabezas serán, inevitablemente, mejor que una.</strong></blockquote>
        <p>Pienso que el futuro del <em>software</em> libre será cada vez más de la gente que sabe cómo jugar el juego de Linus, la gente que deja atrás la catedral y abraza el bazar. Esto no quiere decir que la visión y la brillantez individuales ya no importen; al contrario, creo que en la vanguardia del <em>software</em> libre estarán quienes comiencen con visión y brillantez individual, y luego las enriquezcan construyendo positivamente comunidades voluntarias de interés.</p>
        <p>A lo mejor este no solo es el futuro del <em>software</em> libre. Ningún desarrollador comercial sería capaz de reunir el talento que la comunidad de Linux es capaz de invertir en un problema. ¡Muy pocos podrían pagar tan solo la contratación de las más de doscientas personas que han contribuido a Fetchmail!</p>
        <p>Es posible que a largo plazo triunfe la cultura del <em>software</em> libre, no porque la cooperación sea moralmente correcta o porque la «apropiación» del <em>software</em> sea moralmente incorrecta (suponiendo que se crea realmente en esto último, lo cual no es cierto ni para Linus ni para mí), sino simplemente por que el mundo comercial no es capaz de ganar una carrera armamentista a las comunidades de <em>software</em> libre, las cuales pueden poner más tiempo calificado en un problema que cualquier otra compañía.</p>
        <h2>Reconocimientos</h2>
        <p>Este artículo&#160;fue mejorado gracias a las conversaciones con un gran número de personas que me ayudaron a perfeccionarlo. En especial, agradezco a Jeff Dutky, quien sugirió el planteamiento de que «la búsqueda de errores pude hacerse en paralelo» y ayudó a ampliar el análisis respectivo. También agradezco a Nancy Lebovitz por su sugerencia de imitar a Weinberg al citar a Kropotkin. Asimismo, recibí críticas perspicaces de Joan Eslinger y de Marty Franz de la lista de General Technics. Paul Egger me hizo ver el conflicto entre la <span class="versalitas">gpl</span> y el modelo bazar. Agradezo también a los integrantes del Grupo de Usuarios de Linux de Filadelfia (<span class="versalitas">plug</span>, por sus siglas en inglés), por convertirse en el primer público para la primera versión de este artículo. Finalmente, los comentarios de Linus Torvalds fueron de mucha ayuda y su apoyo inicial fue muy estimulante.</p>
        <h2>Otras lecturas</h2>
        <p>He citado varias partes del clásico de Frederick Brooks, <em>The mythical man-month</em>, debido a que en muchos aspectos todavía se tienen que mejorar sus puntos de vista. Yo recomiendo con cariño la edición del <span class="versalitas">xxv</span> aniversario de Addison-Wesley, que viene junto con su artículo&#160;titulado «No hay balas de plata».</p>
        <p>La nueva edición trae una invaluable retrospectiva de veinte años, en la que Brooks admite francamente ciertas críticas al texto original que no pudieron mantenerse con el tiempo. Leí por primera vez la retrospectiva después de que estaba esencialmente terminado este artículo, y me sorprendí al encontrar que Brooks ¡le atribuye a Microsoft prácticas semejantes a las de bazar!</p>
        <p><em>The psychology of computer programming</em>, de Gerald  Wienberg, introdujo el concepto de «programación sin ego». A pesar de que él estaba muy lejos de ser la primera persona en comprender la futilidad del «principio de orden», fue probablemente el primero en reconocer y argumentar el tema en relación con el desarrollo de <em>software</em>.</p>
        <p>Richard P. Gabriel, al analizar la cultura de Unix anterior a la era de Linux, planteaba la superioridad de un primitivo modelo estilo bazar en un artículo&#160;de 1989 «<em>Lisp: good news, bad news, how to win big</em>». Pese a estar atrasado en algunos aspectos, este ensayo todavía es muy celebrado por los admiradores de Lisp (entre quienes me incluyo). Un corresponsal me recordó que la sección&#160;titulada «Peor es mejor» predice con gran exactitud a Linux.</p>
        <p>El trabajo de Tom DeMarco y Timothy Lister, <em>Peopleware: productive projects and teams</em>, es una joya que ha sido subestimada. Para mi fortuna, fue citada por Fred Brooks. A pesar de que poco de lo que dicen los autores es directamente aplicable a las comunidades de <em>software</em> libre o de Linux, su visión sobre las condiciones necesarias para un trabajo creativo es aguda y muy recomendable para quien intente llevar algunas de las virtudes del modelo bazar a un contexto más comercial.</p>
        <h2>Epílogo: ¡Netscape adopta el modelo bazar!</h2>
        <p>Es un extraño sentimiento el que se percibe cuando uno comprende que está ayudando a hacer historia...</p>
        <p>El 22 de enero de 1998, aproximadamente siete meses después de que publiqué este artículo, Netscape Communications anunció planes para liberar el código fuente de Netscape Communicator. No tenía idea alguna de que esto iba a suceder antes de la fecha de anuncio.</p>
        <p>Eric Hahn, vicepresidente ejecutivo y director de tecnología en Netscape, me mandó un correo electrónico poco después del anuncio, que dice textualmente: «De parte de todos los que integran Netscape, quiero agradecerle por habernos ayudado a llegar hasta este punto, en primer lugar. Su pensamiento y sus escritos fueron inspiraciones fundamentales en nuestra decisión».</p>
        <p>La siguiente semana realicé un viaje en avión a Silicon Valley como parte de la invitación para realizar una conferencia de todo un día sobre cómo crear estrategias (el 4 de febrero de 1998), con algunos de sus técnicos y ejecutivos de mayor nivel. Juntos diseñamos la estrategia de publicación del código fuente de Netscape y la licencia, y realizamos algunos otros planes de los cuales esperamos que eventualmente tengan implicaciones positivas de largo alcance sobre la comunidad de código abierto. Por el momento, mientras escribo, es demasiado pronto para ser más específico, pero se van a ir publicando los detalles en las semanas por venir.</p>
        <p>Netscape está a punto de proporcionarnos con una prueba a gran escala, en el mundo real, del modelo bazar dentro del ámbito empresarial. La cultura del código abierto ahora enfrenta un peligro: si no funcionan las acciones de Netscape, entonces el concepto del código abierto puede llegar a desacreditarse de tal manera que el mundo empresarial no lo abordará nuevamente sino hasta en una década.</p>
        <p>Por otro lado, esto es también una oportunidad espectacular. La reacción inicial hacia este movimiento en Wall Street y en otros lados fue cautelosamente positiva. Nos están proporcionando una oportunidad de demostrar que nosotros podemos hacerlo. Si Netscape recupera una parte significativa del mercado mediante este movimiento, puede desencadenar una revolución ya muy retrasada en la industria de <em>software</em>.</p>
        <p>El siguiente año deberá ser un periodo muy interesante y de intenso aprendizaje.</p>
        <!-- Agregado en esta edición -->
        <h2>Índice de aforismos</h2>
        <ol>
            <li><p><a href="#afor1">Todo buen trabajo de <em>software</em> comienza a partir de las necesidades personales de quien programa. (Todo buen trabajo empieza cuando uno tiene que rascarse su propia comezón).</a></p></li>
            <li><p><a href="#afor2">Los buenos programadores saben qué escribir. Los mejores, qué rescribir (y reutilizar).</a></p></li>
            <li><p><a href="#afor3">Contempla desecharlo; de todos modos tendrás que hacerlo.</a></p></li>
            <li><p><a href="#afor4">Si tienes la actitud adecuada, encontrarás problemas interesantes.</a></p></li>
            <li><p><a href="#afor5">Cuando se pierde el interés en un programa, el último deber es heredarlo a un sucesor competente.</a></p></li>
            <li><p><a href="#afor6">Tratar a los usuarios como colaboradores es la forma más apropiada de mejorar el código, y la más efectiva de depurarlo.</a></p></li>
            <li><p><a href="#afor7">Libera rápido. Libera a menudo. Y escucha a tus clientes.</a></p></li>
            <li><p><a href="#afor8">Dada una base suficiente de colaboradores y <em>beta testers</em>, casi cualquier problema puede ser identificado rápidamente y su solución será obvia al menos para alguien.</a></p></li>
            <li><p><a href="#afor9">Las estructuras de datos inteligentes y el código burdo funcionan mucho mejor que en el caso inverso.</a></p></li>
            <li><p><a href="#afor10">Si tratas a tus analistas (<em>beta testers</em>) como si fueran tu recurso más valioso, ellos te responderán convirtiéndose en tu recurso más valioso.</a></p></li>
            <li><p><a href="#afor11">Lo más grande, después de tener buenas ideas, es reconocer las buenas ideas de tus usuarios. Esto último es a veces lo mejor.</a></p></li>
            <li><p><a href="#afor12">Frecuentemente, las soluciones más innovadoras y espectaculares surgen al darte cuenta de que la concepción del problema era errónea.</a></p></li>
            <li><p><a href="#afor13">La perfección —en diseño— se alcanza no cuando ya no hay nada que agregar, sino cuando ya no hay algo que quitar.</a></p></li>
            <li><p><a href="#afor14">Toda herramienta debe resultar útil en la forma prevista, pero una gran herramienta te permite usarla de la manera menos esperada.</a></p></li>
            <li><p><a href="#afor15">Cuando se escribe <em>software</em> para una puerta de enlace de cualquier tipo, hay que tomar la precaución de alterar el flujo de datos lo menos posible, y ¡nunca eliminar información a menos que los receptores obliguen a hacerlo!</a></p></li>
            <li><p><a href="#afor16">Cuando tu lenguaje está lejos de un Turing completo, entonces puedes endulzar tu sintaxis.</a></p></li>
            <li><p><a href="#afor17">Un sistema de seguridad es tan seguro como secreto. Cuídate de los secretos a medias.</a></p></li>
            <li><p><a href="#afor18">Para resolver un problema interesante, comienza por encontrar un problema que te resulte interesante.</a></p></li>
            <li><p><a href="#afor19">Si el coordinador de desarrollo tiene un medio al menos tan bueno como lo es el internet y sabe dirigir sin coerción, muchas cabezas serán, inevitablemente, mejor que una.</a></p></li>
        </ol>
        <!-- Ficha -->
        <div>
            <p><strong>Título original</strong></p>
            <p><em>The cathedral &amp; the bazaar</em></p>
            <p><strong>Traducción</strong></p>
            <p>José Soto Pérez</p>
            <p><strong>Origen del contenido para esta edición</strong></p>
            <p><a target="_blank" href="http://biblioweb.sindominio.net/telematica/catedral.html">http://biblioweb.sindominio.net/telematica/catedral.html</a></p>
            <p><strong>Fecha de publicación</strong></p>
            <p>Mayo de 1997</p>
            <p><strong>Tipo de licencia</strong></p>
            <p>Desconocida (probablemente <em>copyleft</em>)</p>
        </div>
    </body>  
</html>
